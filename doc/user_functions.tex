\section{User functions}\label{user_functions}
User functions are a flexible way to add functionality at server side.
For example, if one would like to atomically increment a counter, 
without user functions one first has to do a \emph{get} 
and then a \emph{test\_and\_set}, and if there was a race, retry.
With user functions this is quite simple. 
User functions are compiled separately, and dynamically loaded at node startup time.
\paragraph{}
There are three steps in installing a user function.
\begin{itemize}
\item{implement the function}
\item{register the function in the registry}
\item{configure the node to load the module at startup time}
\end{itemize}


\subsection{Implementing a user function}
When called, a user function gets passed a parameter of class type \emph{user\_db}.
The \emph{user\_db} class type provides the interface for manipulating the store. 
Each call to a user function is executed \emph{inside a transaction}

\begin{lstlisting}[language=Caml]
class type user_db = 
object 
  method set : string -> string -> unit
  method get : string -> string
  method delete: string -> unit
  method test_and_set: string -> string option -> string option -> 
          string option
  method range_entries: 
      string option -> bool -> 
      string option -> bool -> int -> (string * string) list 
end

\end{lstlisting}

User functions have the following type:

$$
\text{user\_db} \rightarrow 
\text{string option} \rightarrow \text{string option} 
$$

Within the body of the user function, 
one can make calls upon the \emph{user\_db} object that is passed in.
A sample implementation, for incrementing a counter is provided below.

\begin{lstlisting}[language=Caml]
  (* file : plugin_incr_counter.ml *)
  let incr_counter db ko = 
      match ko with
      | None -> 
          raise (Arakoon_exc.Exception(E_UNKNOWN_FAILURE, ``invalid arg''))
      | Some key -> 
          let counter = 
              try int_of_string(db # get key) 
              with Not_found -> 0 
          in
          let nv = string_of_int (counter + 1) in
          let () = db # set key nv in
          None
 
  let () = Registry.register ``incr_counter'' incr_counter
\end{lstlisting}
The last line of the module takes care of the registration of the function.
\subsection{registration}
Registration is very simple: It's done by calling \emph{Registry.register}, from inside the module that implements the function.

\subsection{extra Node configuration}
The arakoon configuration file needs to have an extra line 
\begin{verbatim}
# file arakoon.ini

...

#plugin module needs to be in home
#plugins = plugin_incr_counter

[arakoon_0]
home = /tmp/arakoon_0

...

\end{verbatim}
This will cause the node to load \emph{plugin\_incr\_counter.cmxs} when it starts. 
This file needs to be available in the home directory of \emph{all} the nodes of the cluster. After the nodes are started, clients can make use of this.

\subsection{Important remarks}
Once a user function is installed, it needs to remain available, with the same functionality for as long as user function calles are stored inside the transaction logs, as they need to be re-evaluated when one replays a transaction log to a store (for example when a node crashed, leaving a corrupt database behind).
\paragraph{}

The input and output are of type \emph{String option}, which means that if you want to pass in a string list, you need to device some kind of (de)marshalling. 
Furtunately, the \emph{Llio} module is available both on client and server side, and has most things you need.
