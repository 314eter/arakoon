\section{basic client interface}
\subsection{some notation}
Before we can descibe the client's interface, 
we need to introduce some notational tools to make it easier to convey things in a concise manner.

\begin{table}[h]
\begin{tabular}{|l|l|}
\hline
  notation & how to read it \\
\hline
  :                & has type \\
unit               & aka void  \\
x list             & a list of items of type x \\
x array            & a fixed size sequence of items of type x \\
x option           & either (Some x) or None \\
string             & char array \\

$ x \rightarrow y$ & a function from x to y \\
x C.t              & something that \emph{eventually yields} something of type x \\
\hline
\end{tabular}
\end{table}

For example $ a : string $ just means that $a$ is a $string$;
$fibonacci : int \rightarrow int$ just means that fibonnacci is a function that takes an integer, and returns an integer as result;
$cat : string \rightarrow string \rightarrow string$ reads as 'cat is a function that takes 2 strings and returns a string as result'

$write: channel \rightarrow string \rightarrow unit\ C.t$ reads as 'write takes a channel and a string and eventually yields unit.


A client has a dictionary interface with some adjustments for latency: the functions have a return value of type $a\ C.t$.
\paragraph{type key = string}
Keys are strings.
There are no strict size limitations, which means that they such be small enough to be handled in their entirety
\paragraph{type value = string}
Values are strings too.
\paragraph{type update}
An update is either $Set(key,value)$ or $Delete(key)$.

\paragraph{exists : key $\rightarrow$ bool C.t} See if a value exists for a specific key, without retrieving it.

\paragraph{get : key $\rightarrow$ value C.t}
You can look up a value if you have the key. It will eventually yield either a value, or raise an exception.

\paragraph{set : key $\rightarrow$ value $\rightarrow$ unit C.t}
You can update a value for a key, regardless of current value (if any).

\paragraph{confirm : key $\rightarrow$ value $\rightarrow$ unit C.t}
If \emph{get key} would yield this \emph{value} then this does nothing, 
else, it behaves as a set.

\paragraph{delete : key $\rightarrow$ unit C.t}
You can remove a key/value pair. 
There was a suggestion to open this op to allow a regular expression.

\paragraph{test\_and\_set : key $\rightarrow$ value option $\rightarrow$ value option $\rightarrow$ (value option) C.t} This is a careful update.
\emph{test\_and\_set k expected new} only modifies the value to \emph{new} if the old value is \emph{expected}.
The originaly stored value will be returned.
Using a \emph{value option} instead of a value allows you to only set a value only if there was none for that key.
Using \emph{None} as new allows you to do a careful delete as well.

\paragraph{range : key option $\rightarrow$ bool $\rightarrow$
  key option $\rightarrow$ bool $\rightarrow$
  int $\rightarrow$ key list C.t}
\emph{range bkey binc ekey einc max} will yield a list of keys where
$max$ is the maximum number of keys (if $max < 0$ then you want them all).
The keys fall in the range \emph{kbey..ekey}.
\emph{binc} and \emph{einc} specify if the borders are included (\emph{true}) or not.

\paragraph{range\_entries: key option $\rightarrow$ bool $\rightarrow$
  key option $\rightarrow$ bool $\rightarrow$
  int $\rightarrow$ bool $\rightarrow$ (key * value) list C.t
}
will yield a list of key value pairs.
The parameters have the same semantics as for the range method.


\paragraph{sequence: update list $\rightarrow$ unit C.t}
Provides an atomic multi-update. Either all updates are performed or none. 
While this is not a full transaction, it provides enough functionality to safeguard consistency.

\paragraph{assert : key $\rightarrow$ value option $\rightarrow$ unit C.t}
\emph{assert key vo} throws an exception if the value associated with the key is not what was expected. 
This can be used to interrupt sequences.

%\paragraph{hello : string $\rightarrow$ string $\rightarrow$ string C.t}
%The client identifies itself to the server and tells the server the cluster id, and the server replies with its version string.

\paragraph{who\_master: unit $\rightarrow$ string option C.t}
Allows the client to know which node currently acts as master.
If there is no master, or it is not known to this node, the result is None.
%
%\paragraph{last\_entries: int $\rightarrow$ out\_channel $\rightarrow$ unit C.t}
%allows the client to stream the transaction log into a channel, starting from entry $i$

\paragraph{multi\_get: key list $\rightarrow$ (value list) C.t}
Allows you to fetch multiple values in one roundtrip to the server.

\paragraph{expect\_progress\_possible: unit $\rightarrow$ bool C.t}
Asks the master node if it thinks progress is possible. 
This means that the master has seen enough that indicates enough slaves are still following its lead. 
False positives are possible.

\paragraph{user\_function: string $\rightarrow$ 
  string option $\rightarrow$ 
  string option C.t}
Allows user registered manipulation of the store. 
More about this in \ref{sec:user_functions}

\paragraph{get\_key\_count: unit $\rightarrow$ int64 C.t}
Yields the number of items stored in arakoon.
